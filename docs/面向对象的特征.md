# 面向对象的特征
封装：
抽象：
继承：
多态：

## 封装：
一个类就是一个封装，过
![](2018-04-23-17-46-09.png)

![](2018-04-23-17-58-15.png)

~~~
package  com.dingyi.tai.demo1.hello;
class Person{

    String name;
    String password;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }



}
~~~

##  继承
## 三、      多态
　　方法的重写、重载与动态连接构成多态性； 

　　Java之所以引入多态的概念，原因之一是它在类的继承问题上和C++不同，后者允许多继承，这确实给其带来的非常强大的功能，但是复杂的继承关系也给C++开发者带来了更大的麻烦，为了规避风险，Java只允许单继承，派生类与基类间有IS-A的关系（即“猫”is a “动物”）。这样做虽然保证了继承关系的简单明了，但是势必在功能上有很大的限制，所以，Java引入了多态性的概念以弥补这点的不足，此外，抽象类和接口也是解决单继承规定限制的重要手段。同时，多态也是面向对象编程的精髓所在。 

　　要理解多态性，首先要知道什么是“向上转型”。 

　　我定义了一个子类Cat，它继承了Animal类，那么后者就是前者的父类。我可以通过

　　Cat c = new Cat();       例化一个Cat的对象，这个不难理解。

　　但当我这样定义时： Animal a = new Cat();

　　这代表什么意思呢？

　　很简单，它表示我定义了一个Animal类型的引用，指向新建的Cat类型的对象。由于Cat是继承自它的父类Animal，所以Animal类型的引用是可以指向Cat类型的对象的。那么这样做有什么意义呢？因为子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特，定义一个父类类型的引用指向一个子类的对象既可以使用子类强大的功能，又可以抽取父类的共性。所以， 

　　父类引用只能调用父类中存在的方法和属性，不能调用子类的扩展部分；因为父类引用指向的是堆中子类对象继承的父类；（但是如果强制把超类转换成子类的话，就可以调用子类中新添加而超类没有的方法了。） 

　　同时，父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用； 

　　对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。


